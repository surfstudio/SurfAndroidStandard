# Общие принципы и требования к коду

[TOC] [][<-- эта штука делает оглавление в битбакете, пока надо протестить ее возможности]

## DRY, SOLID, KISS, YAGNI

В нашей работе мы стараемся следовать приведенным выше [принципам](http://www.stijit.com/web-tips/dry-kiss-solid-yagni).

## Управление сложностью

Управление сложностью должно являться главным техническим императивом каждого
разработчика. Если посмотреть в общем, то все ключевые технологии (к примеру ООП),
лучшие практики (те же SOLID, KISS, DRY), различные архитектурные шаблоны(MVC,
CleanArchitecture) создавались в том числе для того, чтобы уменьшать
сложность кода, и все это из-за способностей человеческого разума. Как бы
мы нам не было неприятно это осознавать, но человек ограничен и не может
понимать как работают системы любой сложности.

Отсюда и вытекают в том числе требования к иерархичности(слои абстракции) и
единственной ответственности элементов чтобы человек мог в один момент времени
продуктивно работать с одной небольшой и достаточно независимой
частью системы.

[С. Макконнелл “Совершенный код”](https://drive.google.com/file/d/0B9HiaK6QQBxKZndPcDBIVUhlb3c/view) Управление сложностью глава 5.2

## Принцип единой ответственности (S in SOLID)

Один из самых важных принципов в нашей студии. Заключается в том, что все структурные элементы(модуль, пакет, класс, метод,
переменная, параметр метода и тд) должны иметь единственную зону ответственности.
Если таких зон нескольку данную структурную единицу нужно разделить.
Другими словами, если класс или метод чем-то занимается, то он должен
делать только это и ничего другого.

[подробнее](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%B5%D0%B4%D0%B8%D0%BD%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8)

## Уровни абстракции

*Примечание*. Этот раздел о выделении абстракции на низком уровне в рамках
одного класса.

Помимо разделения кода на функциональные части, необходимо разделять код на
различные уровни абстракции. Количество данных уровней зависит от сложности
и объема задачи к которой это разделение применяется.
Один уровень абстракции определяет примерно один уровень детализации.
Если рассматривать неприватные методы класса, образующие его интерфейс,
то они должны быть максимально возможно абстрагированы, в них не должна
отображаться внутренняя реализация. Эти неприватные методы в свою очередь
должны состоять из приватных методов понижающих уровень абстракции, они же
в свою очередь состоят из других приватных методов одного уровня понижающих
абстракцию и так далее.

[**Пример**](https://gist.github.com/icebail/aab425a46efab03a1024df5dbc553763)

Выделение уровней абстракций в коде позволяет человеку работающему с кодом
быстрее в нем разобраться, вникая в детали реализации до необходимого уровня.

Хотя в этом разделе раскрыта тема о выделении абстракци на низком уровне
в рамках одного класса эти принципы следует применять и для всех уровней:
 jar(aar) библиотека - пакет - подпакеты - класс - и тд.

При обсуждении уровней абстракции следует также вспомнить *принцип инверсии
зависимостей(D in SOLID)* - `модули верхних уровней не должны зависеть от
модулей нижних уровней`.

## Code-style студии

При разработке требуется соблюдать определеный стиль написания кода. Это помогает
легче ориентироваться и понимать чужой код.

Мы используем следующие:

- [Java Code-style](codestyle/java_codestyle.md)

- [Kotlin Code-style](codestyle/kotlin_codestyle.md)