
[Главная][../main.md]

[TOC]

# Модули внутренней логики

## Общие принципы

Как описывалось ранее, архитектура приложения является упрощенным вариантом
[**Clean Architecture**][clean] (*не приступайте к чтению этой статьи без ознакомления с
[общим описанием нашей архитектуры и принципах на которых она построена][archs]*).
Слой *Interactor* соответствует слоям *UseCase, Interface Adapters, Web/BD/Framework…*
в терминах *Clean Architecture*. Слой состоит из *модулей*, каждый из которых
имеет строго определенную ответственность (**Не путать с модулем Dagger2**).
Важным моментом является то, что Api этого слоя **не должно зависеть от
Android Framework и других библиотек**. Детали реализации модуля
не должны быть доступны никаким другим частям приложения, кроме этого модуля.
Другими словами, модуль - это некий черный ящик для всех частей приложений,
который предоставляет на высоком уровне абстракции минимальный интерфейс
для работы с ним.

Под внутренней логикой, которая может быть заключена в наших черных ящиках,
можно подразумевать все, что угодно - это может быть и репозиторий,
ответственный за получение или изменение каких-либо данных, это может быть
менеджер, ответственный за загрузку данных на сервер в фоновом режиме,
это даже может быть класс, инкапсулирующий какую-то сложную логику
инициализации приложения (обновление данных, миграции и тд) и таких примеров
можно описать еще много, все зависит от уровня сложности задач и проекта
в целом. Принято под каждый модуль выделять свой ~~package в структуре проекта~~
свой отдельный модуль в терминах Android/Java Library.
Чаще всего модуль это не один какой-то Java-класс, но не стоит думать,
что это обязательно нечто большое и сложное. Главное это то, что этот модуль
выполняет строго определенные ему обязанности и инкапсулирует всю бизнес-логику
внутри себя. Важно заметить, что каждый такой “модуль” может содержать в себе
один или даже несколько пакетов, которые выполняют конкретную работу внутри модуля.
Причем такие внутренние пакеты ничего не должны знать о внешнем "мире".

Рассмотрим наиболее распространенные “модули внутренней логики”.

###### 1. Репозиторий

Говоря о репозиториях, следует вспомнить паттерн, который собственно
так и называется “Репозиторий”. Суть его в том, чтобы создать некий слой
абстракции над какими-либо конкретными источниками данных, будь то например
ваша база данных или веб-сервис или все вместе. Задача репозитория стать
промежуточным звеном между тем кто запрашивает данные и тем кто их отдает.
Важно понимать, что все что находится выше репозитория не должно знать о том,
как он устроен и откуда он берет эти данные. Это может быть сетевой запрос,
запрос в базу данных или же все вместе, так называемый гибридный запрос,
который подразумевает проведение конкатенации запросов на сервер и кеш по
некому установленному вами правилу.

Выделение такого “модуля” (репозитория) делает вашу архитектуру более гибкой,
и она с легкостью может быть адаптирована по мере развития общей конструкции
приложения.

Пакет(модуль), соответствующий репозиторию должен, кроме самого репозитория,
содержать:

- Интерфейс Api для Retrofit

- Модели для парсинга ответов сервера

- Модели для формирования запроса к серверу

- Класс кеша для этого репозитория, и сопутствующие ему другие классы

- Остальные детали, которые скрываются под абстракцией репозитория


###### 2. Location Module

Определение геолокации не всегда простая задача, особенно если в вашем
приложение точное определение местоположения играет ключевую роль.
Геолокацию можно определить несколькими способами - это может быть
стандартный LocationManager в Android, это может быть PlayServices, это
может быть запрос в сеть и др. В свою очередь каждый из этих способов может
работать с высокой точностью или с низкой, через GPS или WI-FI, с использованием
последней успешной локации или без и тд. Все эти точные настройки и алгоритмы
должны быть прикрыты большим уровнем абстракции. Подразумевается, что данный
модуль имеет, к примеру, один публичный метод getLocation(), который возвращает
текущую локацию пользователя. Но как и откуда эта локация была получена знает
только сам модуль.

Для использования локации уже существует [готовый модуль][../../location/README.md].

###### 3. Модуль инициализации

Инициализация приложения чаще всего происходит на экране сплеша.
Под инициализацией понимается выполнение определенного набора правил, от
которых зависит дальнейшее поведение приложения. Например, миграции приложения
на новую версию или же получение и обновление токена, получение локации и тд.

Принято выделять данную логику в модуль. Данный модуль чуть сложнее предыдущих,
т.к он может включать в себя еще ряд таких же модулей, каждый из которых
ответственен за свою задачу (например, модуль локации, модуль миграции).

Интерфейс данного модуля будет описан всего лишь одним методом - initialize().
Пакет этого модуля будет содержать, как минимум, данный интерфейс и класс,
реализующий его и инкапсулирующий всю логику этого модуля.

###### 4. Модуль смены сессии пользователя

Данный модуль инкапсулирует действия, которые необходимо выполнить при
смене сессии или пользователя. Среди таких действий могут быть - очистка
кэша, запрос на logout, кэширование токена и тд.

Реализация этого модуля включает в себя работу с репозиторями, которые,
как мы помним, являются такими же модулями. Например, UserRepository и TokenStorage.

[archs]: ../common/architect.md
[clean]: https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html