
[Главная](../main.md)

[TOC]

# Слой Interactor

Относится к **Model** в терминах **MVP**.

### Что такое Interactor?
todo

### Описание слоя

**Interactor** - содержит внутреннюю(бизнес) логику приложения.
Этот слой предоставляет доступ к хранилищам данных и другим сервисам.
Api этого слоя не должно зависеть от **Android Framework и других библиотек**.

Слой *Interactor* соответствует слоям *UseCase, Interface Adapters, Web/BD/Framework…*
в терминах [**Clean Architecture**][clean]. Он состоит из *android-модулей*,
каждый из которых имеет строго определенную ответственность.
Детали реализации модуля не должны быть доступны никаким другим
частям приложения, кроме этого модуля.

Бизнес-логика должна быть максимально отделена от деталей реализации.

Другими словами, модуль - это некий черный ящик для всех частей приложений,
который предоставляет на высоком уровне абстракции минимальный интерфейс
для работы с ним.

Под внутренней логикой, которая может быть заключена в наших черных ящиках,
можно подразумевать все, что угодно - это может быть и репозиторий,
ответственный за получение или изменение каких-либо данных, это может быть
менеджер, ответственный за загрузку данных на сервер в фоновом режиме,
это даже может быть класс, инкапсулирующий какую-то сложную логику
инициализации приложения (обновление данных, миграции и тд) и таких примеров
можно описать еще много, все зависит от уровня сложности задач и проекта
в целом.

Именно на этом уровне должно происходить трансформирование структур данных,
используемых во внешних хранилищах, в модели слоя Domain.

Подробное описание архитектуры приложений - [здесь][../common/architect.md].

### Типовые сущности, принадлежащие слою Interactor

Рассмотрим наиболее распространенные сущности, принадлежащие к этому слою.

###### 1. Репозиторий

Говоря о репозиториях, следует вспомнить паттерн, который собственно
так и называется “Репозиторий”. Суть его в том, чтобы создать некий слой
абстракции над какими-либо конкретными источниками данных, будь то например
ваша база данных или веб-сервис или все вместе. Задача репозитория стать
промежуточным звеном между тем кто запрашивает данные и тем кто их отдает.
Важно понимать, что все что находится выше репозитория не должно знать о том,
как он устроен и откуда он берет эти данные. Это может быть сетевой запрос,
запрос в базу данных или же все вместе, так называемый гибридный запрос,
который подразумевает проведение конкатенации запросов на сервер и кеш по
некому установленному вами правилу.

Выделение такого “модуля” (репозитория) делает вашу архитектуру более гибкой,
и она с легкостью может быть адаптирована по мере развития общей конструкции
приложения.

Пакет(модуль), соответствующий репозиторию должен, кроме самого репозитория,
содержать:

- Интерфейс Api для Retrofit

- Модели для парсинга ответов сервера

- Модели для формирования запроса к серверу

- Класс кеша для этого репозитория, и сопутствующие ему другие классы

- Остальные детали, которые скрываются под абстракцией репозитория

###### 2. Location Module

Определение геолокации не всегда простая задача, особенно если в вашем
приложение точное определение местоположения играет ключевую роль.
Геолокацию можно определить несколькими способами - это может быть
стандартный LocationManager в Android, это может быть PlayServices, это
может быть запрос в сеть и др. В свою очередь каждый из этих способов может
работать с высокой точностью или с низкой, через GPS или WI-FI, с использованием
последней успешной локации или без и тд. Все эти точные настройки и алгоритмы
должны быть прикрыты большим уровнем абстракции. Подразумевается, что данный
модуль имеет, к примеру, один публичный метод getLocation(), который возвращает
текущую локацию пользователя. Но как и откуда эта локация была получена знает
только сам модуль.

Для использования локации уже существует [готовый модуль][../../location/README.md].

###### 3. Модуль инициализации

Инициализация приложения чаще всего происходит на экране сплеша.
Под инициализацией понимается выполнение определенного набора правил, от
которых зависит дальнейшее поведение приложения. Например, миграции приложения
на новую версию или же получение и обновление токена, получение локации и тд.

Принято выделять данную логику в модуль. Данный модуль чуть сложнее предыдущих,
т.к он может включать в себя еще ряд таких же модулей, каждый из которых
ответственен за свою задачу (например, модуль локации, модуль миграции).

Интерфейс данного модуля будет описан всего лишь одним методом - initialize().
Этот модуль будет содержать, как минимум, данный интерфейс и класс,
реализующий его и инкапсулирующий всю логику этого модуля.

###### 4. Модуль смены сессии пользователя

Данный модуль инкапсулирует действия, которые необходимо выполнить при
смене сессии или пользователя. Среди таких действий могут быть - очистка
кэша, запрос на logout, кэширование токена и тд.

Реализация этого модуля включает в себя работу с репозиторями, которые,
как мы помним, являются такими же модулями. Например, UserRepository и TokenStorage.


[clean]: https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html