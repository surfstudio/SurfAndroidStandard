[Главная](../main.md)

[TOC]

# Навигация

Навигация в наших приложениях построена не на использовании Intent'ов напрямую,
а на использовании т.н. "маршрутов" - *Route*, и навигаторов - *Navigator*.

Такой подход хорош тем, что позволяет скрыть в одном объекте все, что связано
с навигацией для конкретного экрана (пункт назначения, параметры, результат).
Также это помогает скрыть низкоуровневые детали фреймворка
и использовать такие сущности в презентере. При этом сами понятия `Route` и
`Navigator` - довольно абстрактные, тем самым всю навигацию можно построить
на этих двух сущностях.

Route - является оберткой над Intent(навигация по активити) или хранит
имя класса фрагмента(для навигации по фрагментам).
Для фрагментов и диалогов Route также является оберткой над Bundle.

Навигация между экранами должна происходить только из слоя Presenter.

Для навигации по приложению предусмотрены сущности `Navigator`(поставляются
модулями *[core-ui][core-ui], [mvp-dialog][dial]*). `Navigator` осуществляет
навигацию в соответствии с переданным ему объектом `Route`.

`Route` может быть использован и без навигатора: например, внутри `PagerAdapter`
для фрагментов он будет использован для создания фрагмента
```
    oneFragmentRoute().createFragment()
    twoFragmentRoute().createFragment()
```

Или для создания PendingIntent (например, при работе с Notification).

`Route`, кроме определения какой конкретно экран открывать, может быть
ответственен за:

-  упаковку данных в Intent (Bundle) для передачи аргументов в экран, диалог

-  распаковку данных из Intent (Bundle) переданных в экран, диалог

-  упаковку данных в Intent для передачи результата на предыдущий экран

-  распаковку данных результата выполнения экрана из Intent

-  упаковку неявного Intent для перхода в другое приложение


Для реализации навигации, необходимо реализовать класс-наследник одного из базовых
`Route`.

Передача параметров при старте экрана происходит через `Route`
и эти параметры получает презентер в конструктор также обернутые в `Route`.
Для упрощения этой передачи следует создать базовый класс для модуля экрана
`CustomScreenModule`.

``` kotlin
@Module
abstract class CustomScreenModule<out R : Route>(private val route: R) {

    @Provides
    @PerScreen
    fun provideRoute(): R {
        return route
    }
}
```


Более подробно [Основные Routes и Navigators][nav], [Навигаторы для диалогов][dial]

[core_ui]: ../../core-ui/lib-core-ui/README.md
[nav]: ../../core-ui/lib-core-ui/docs/navigation.md
[dial]: ../../mvp/lib-mvp-dialog/README.md
