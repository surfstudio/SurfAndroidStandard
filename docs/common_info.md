# Общие сведения о построении приложения

### 1. Архитектура приложения
Архитектура построена на упрощённой версии **СleanArcitecture**, адаптированной под мультимодульную архитектуру.

Основной причиной для выбора описанной архитектуры было стремление уменьшить сложность проекта. В частности использовались 2 основных принципа:

- Принцип единственной ответственности (разделение на слои, модули)
- Инкапсуляция (сокрытие реализации от остальных частей приложения)


*Приложение состоит из следующих основных слоев*:

* Domain - содержит сущности и логику предметной области.
* Interactor - содержит внутреннюю(бизнес) логику приложения. Этот слой предоставляет доступ к хранилищам данных и другим сервисам. Api этого слоя не должно зависеть от Android Framework и других библиотек. Слой Interactor состоит из модулей, каждый из которых имеет строго определенную ответственность. Детали реализации каждого модуля не должны быть доступны никаким другим частям приложения, кроме этого модуля. На этом уровне должно происходить трансформирование структур данных, используемых во внешних хранилищах, в модели слоя Domain. Бизнес логика должна быть максимально отделена от деталей реализации.
* UI - содержит логику пользовательского интерфейса
   * Presenter - содержит логику экранов. В презентере происходят все манипуляции с данными, изменение данных внутри View недопустимо. Презентеры не должны содержать бизнес логику приложения.
   * View - слой представления, отвечает за взаимодействие с пользователем. Вью не должна  содержать логику экрана, только логику отображения. Вью должна быть максимально пассивной.


Каждый последующий слой может зависеть только от предыдущего и от слоя Domain.
Каждый класс принадлежит только одному из вышеперечисленных слоев.


### 2. Многомодульность

Многомодульное приложение обладает следующими преимуществами:
- скорость сборки
- паралельная сборка модулей
- изоляция слоев

В студийной архитектуре выделяем следующие модули:
-  app-injector - основной модуль приложения(точка входа). Знает обо всех модулях и
является **единственным модулем с даггер зависимостями**. От него не зависит ни один другой модуль,
он же зависит от всех.

- domain - слой **Domain**. Содержит все ,
что касается доменной области( модели данных).
- base - базовый модуль. Здесь объявляются зависимости необходимые во всех других модулях
(через api). Также содержит базовые сущности , использующиеся как в i-, так в f-модулях.
- base-ui - базовый слой для модулей фич и вообще пользовательских представлений.
Зависит от base.

- f-*name* - feature-модули. Модули, в которых ведется разработка конкретной фичи.
Это может быть несколько экранов с одной семантикой (например авторизация), может быть один большой экран со сложной логикой.
**Не зависят друг от друга!!!**
- cf-*name* - common-feature-модули. Модули c фичами, которые переиспользуются в других фичах.
**Не зависят друг от друга!!!**
- i-*name* - модули-интеракторы. Данные модули принадлежат слою **Interactor**.
Могут выполнять конкретный UseCase, могут содержать несколько интеракторов.
**Могут зависеть друг от друга.**


При таком разбиении изменение одного фича-модуля влекут процесс сборки только в нем и в app-injector.

Подробное описание подхода: [здесь](../template-multimodile/README.md)

### 3. Инъекция зависимостей
ссылки на dagger-scope

*Инъекция зависимостей* реализована с помощью библиотеки **Dagger 2**.
Область видимости более высокого уровня расширяет область видимости более низкого уровня.

В приложении есть 2 основных вида Scope (области видимости):

* Scope приложения (аннотация @PerApplication) - предоставляет объекты, слоя Interactor. Эти объекты являются синглтонами.
* Scope активити (аннотация @PerActivity) - предоставляет обьекты, привязанные к жизненному циклу Активити (например RxBus). Этот Скоуп рамполагается между PerApplication и PerScreen. Не забывайте пробрасывать обьекты из PerAplication в PerScreen через AppComponent и ActivityComponent.
* Scope экрана (аннотация @PerScreen) - предоставляет объекты, привязанные к жизненному циклу экрана

@PerScreen может применяться для экранов, основанных как на Activity так и на Fragment.
Разрешается добавлять скоупы для собственных нужд, между уровнем приложения и уровнем экрана. Эти скоупы должны быть описаны в конце этого раздела.

Для каждого экрана создается свой dagger компонент, название компонента должно соответствовать следующему правилу: <название экрана>ScreenComponent.

Этот компонент находится в app-injector, и регистрируется в Storage.
На экране компонент доступен через ComponentProvider.

Все объекты для удовлетворения зависимостей разделены на логически связанные dagger модули.

### 4. Шина сообщений

Шину сообщений использовать можно только для связывание 2-х презентеров в
контексте одной активити. Для шины Предусмотрен класс `RxBus` из *core-ui*.
RxBus относится к скопу @PerActivity.

### 5. Асинхронные взаимодействия

Для подавляющего количества асинхронных задач следует использовать RxJava.
Слой Presenter может взаимодействовать с асинхронными задачами только через Rx,
из-за специфической архитектуры слоев View / Presenter.
Поток, в котором будет выполняться асинхронная задача следует указывать
непосредственно перед подпиской на Observable.
Это необходимо для выполнения составных асинхронных задач в одном
потоке.

Для указания потока выполнения и потока подписки асинхронной
задачи,
обернутой в Observable присутствует класс SchedulersProvider,
предоставляющий доступ к Sheduler главного и рабочего потока.
Использование классов rx.Schedulers и AndroidSchedulers запрещено.
Эта абстракция была создана для возможности тестирования асинхронного
взаимодействия между модулями.

### 6. Логгирование
ссылка на [logger](../logger/README.md)

Логгирование в logcat осуществляется с помощью класса Logger, который является
оберткой над библиотекой Timber. В обязательном порядке логгируются:
* Url запросов и статус ответов сервера
* NonFatalExceptions (состояния приложения, когда часть его функционала
неправильно отработала, но при этом приложение может продолжать работать)

Оставлять логи, которые не несут важной информации запрещено.
Для ожидаемых ошибок предусмотрен метод Logger.w(Throwable),
который логгирует только сообщение ошибки.
Не оставляем пустые обработчики ошибок rx потока.
Не пишем e.printStackTrace().

Для логгирования в Crashlytics предусмотрен класс RemoteLogger.
В RemoteLogger отправляются:
* Все логи Logger’a выше уровня VERBOSE
* Exceptions, которые логгируется через Logger#e(),
отправляются как NonFatalExceptions.(в том числе ошибки парсинга ответа сервера).
__Не забиваем крашлитикс ненужными NonFatal, для ожидаемых ошибок используем Logger.w()__
* События onPause и onResume экранов

?
Кроме того в RemoteLogger также устанавливаются id, имя и email пользователя при входе в аккаунт и очищаются при выходе.

Для отслеживания ANR применяется библиотека AnrWatchDog. При детектировании ANR соответствующий NonFatal отправляется в RemoteLogger.

### 7. Аналитика

Для работы с аналитикой предусмотрен модуль [analytic](https://bitbucket.org/surfstudio/android-standard/src/master/analytics/).
Он содержит базовые сущности и сервисы для работы с аналитикой.