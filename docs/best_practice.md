# Лучшие практики
[ссылка](https://docs.google.com/document/d/1tGf1Z9r16h6swXSGR48qBT2MO5nqia9dZltjg8j2N2o/edit#)


##### Особенности реализации View
**RecyclerView.Adapter** - в качестве адаптера следует использовать EasyAdapter
(не расширяя его). Он имеет следующие свойства:
   - Нет необходимости вызывать методы notify… , они будут автоматически вызваны
   при вызове метода setData() или setItems().
   Для правильной работы этого механизма следует правильно переопределить(часть уже переопределена)
    методы класса ItemController
      - getItemId() - должен возвращать всегда то же значение для элемента
      списка даже если часть данных изменилась,
      например у сущности товара изменился “favorite” статус, getItemId()
      должен возвращать ID товара.
      - getItemHash() - должен возвращать постоянное значение, если данные
      элемента списка не меняются и отличные значения при разных данных.

   - Вводится новая сущность ItemController (базовые классы NoDataItemController и BindableItemController), которая отвечает за отрисовку элементов списка конкретного типа и передачу событий от этих элементов. ItemController должен содержать в себе класс Holder и интерфейс Listener. Listener для событий элементов списка ItemController должен получать в конструктор.
   - Порядок элементов определяется во View с помощью класса ItemList, обьект которого передается в EasyAdapter.

**RecyclerView.ViewHolder** должен полность скрывать все детали android.View, которую он содержит. Для этого следует
Использовать ID ресурса верстки элемента списка внутри конструктора ViewHolder (см базовый класс BaseViewHolder)
Использовать метод bind(data) для отрисовки данных на элементе списка (см базовый класс BindableViewHolder)

Загрузка изображений происходит через класс [ImageLoader](../imageloader/README.md),
который является оберткой над Glide.
Использование этой абстракции позволит легко заменить Glide на любую другую библиотеку;

Ресурсы изображений:
- Для всех иконок используется векторная графика. Для использования векторных
ресурсов нужно указывать атрибут app:srcCompat вместо src.
Векторные ресурсы также используются как иконки в меню тулбара.
Для того чтобы использовать вектора для других случаев,
например drawableLeft, то его следует обернуть в layer-list.
Запрещается использовать класс VectorDrawable для работы с векторными изображениями в
runtime - использовать следует VectorDrawableCompat. [Гайд по использованию векторов](https://developer.android.com/studio/write/vector-asset-studio.html#running);
- Background всех Button и FlatButton сделан через AppCompat стили;
- Все *.png ресурсы только в разрешении xxhdpi, эти ресурсы андроид будет
масштабировать автоматически на более низкие разрешения + переводим в webp;
- Использовать `<shape>` предпочтительнее чем svg и png ресурсы.

MessageController - позволяет показывать SnackBar. Не может использоваться в презентере.
Может использоваться View экрана и дополнительными сущностями скоупа @PerScreen,
например StandardErrorHandler;

Любые локальные действия на экране с AndroidFramework и которые не относятся
к зоне ответственности Вью должны быть обернуты в соответствующие классы с интерфейсом,
независящим от фреймворка и поставляемым в презентер через Dagger.
(например проверка наличия модуля GCM или подписка на BroadcastReceiver)

Вместо нативного ProgressBar используем MaterialProgressBar из этой библиотеки
(для стилизации элемента на prelollipop-устройствах).

NetworkErrorHandler, StandardErrorHandler - обработчик исключений,
возникающих при сетевых запросах;

StandardPlaceHolderView - кастомизируемый плейсхолдер для различных лоад-стейтов.
[custom-view](../custom-view/README.md)

## presenter

Для объединения запросов к репозиториям необходимо использовать
ObservableUtil#combineLatestDelayError() вместо Observable#zip().
Это продиктовано особенностью получения данных.
Каждый Observable может эмитить 2 элемента: один из кеша, другой с сервера.
Observables в этом случае выполняются параллельно.

## ui

Если на экране производится запрос, в течении которого нельзя давать
пользователю взаимодействовать с контентом - используем LoadState.LOADING_TRANSPARENT.
Если при этом запрос не очень важный, лучше блокировать только необходимую часть контента,
при этом демонстрировать PullToRefresh или другой индикатор и скрывать его
при снятии блокировки с UI.


## Interactor

Еще один кейс использования интеракторов: построение событийной модели общения между частями приложения.
Например, некоторое действие на активити А должно вызывать обновление данных на активити Б.
Причем, данное действие не является результатом активити А.
Тогда можно пробросить событие через общий интерактор у данных активити.