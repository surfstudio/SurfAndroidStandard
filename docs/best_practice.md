# Лучшие практики

[][TODO: тут пока текст , который еще не вставили в конкретное место]


## Общие сведения

Архитектура построена на упрощённой версии **СleanArchitecture**,
адаптированной под мультимодульную архитектуру.

Основной причиной для выбора описанной архитектуры было стремление
уменьшить сложность проекта. В частности использовались 2 основных принципа:

- Принцип единственной ответственности (разделение на слои, модули)
- Инкапсуляция (сокрытие реализации от остальных частей приложения)


*Приложение состоит из следующих основных слоев*:

* Domain - содержит сущности и логику предметной области.
* Interactor - содержит внутреннюю(бизнес) логику приложения.
Этот слой предоставляет доступ к хранилищам данных и другим сервисам.
Api этого слоя не должно зависеть от Android Framework и других библиотек.
Слой Interactor состоит из модулей, каждый из которых имеет строго определенную
ответственность. Детали реализации каждого модуля не должны быть доступны
никаким другим частям приложения, кроме этого модуля. На этом уровне должно
происходить трансформирование структур данных, используемых во внешних хранилищах,
в модели слоя Domain. Бизнес логика должна быть максимально отделена от
деталей реализации.
* UI - содержит логику пользовательского интерфейса
  * Presenter - содержит логику экранов. В презентере происходят все манипуляции
  с данными, изменение данных внутри View недопустимо. Презентеры не должны
  содержать бизнес логику приложения.
  * View - слой представления, отвечает за взаимодействие с пользователем.
  Вью не должна содержать логику экрана, только логику отображения. Вью должна
  быть максимально пассивной.


Каждый последующий слой может зависеть только от предыдущего и от слоя Domain.
Каждый класс принадлежит только одному из вышеперечисленных слоев.

##### Особенности реализации View

**RecyclerView.Adapter** - в качестве адаптера следует использовать EasyAdapter
(не расширяя его). Он имеет следующие свойства:
   - Нет необходимости вызывать методы notify… , они будут автоматически вызваны
   при вызове метода setData() или setItems().
   Для правильной работы этого механизма следует правильно переопределить(часть уже переопределена)
    методы класса ItemController
      - getItemId() - должен возвращать всегда то же значение для элемента
      списка даже если часть данных изменилась,
      например у сущности товара изменился “favorite” статус, getItemId()
      должен возвращать ID товара.
      - getItemHash() - должен возвращать постоянное значение, если данные
      элемента списка не меняются и отличные значения при разных данных.

   - Вводится новая сущность ItemController (базовые классы NoDataItemController и BindableItemController), которая отвечает за отрисовку элементов списка конкретного типа и передачу событий от этих элементов. ItemController должен содержать в себе класс Holder и интерфейс Listener. Listener для событий элементов списка ItemController должен получать в конструктор.
   - Порядок элементов определяется во View с помощью класса ItemList, обьект которого передается в EasyAdapter.

**RecyclerView.ViewHolder** должен полность скрывать все детали android.View, которую он содержит. Для этого следует
Использовать ID ресурса верстки элемента списка внутри конструктора ViewHolder (см базовый класс BaseViewHolder)
Использовать метод bind(data) для отрисовки данных на элементе списка (см базовый класс BindableViewHolder)

Загрузка изображений происходит через класс [ImageLoader](../imageloader/README.md),
который является оберткой над Glide.
Использование этой абстракции позволит легко заменить Glide на любую другую библиотеку;

Ресурсы изображений:
- Для всех иконок используется векторная графика. Для использования векторных
ресурсов нужно указывать атрибут app:srcCompat вместо src.
Векторные ресурсы также используются как иконки в меню тулбара.
Для того чтобы использовать вектора для других случаев,
например drawableLeft, то его следует обернуть в layer-list.
Запрещается использовать класс VectorDrawable для работы с векторными изображениями в
runtime - использовать следует VectorDrawableCompat. [Гайд по использованию векторов](https://developer.android.com/studio/write/vector-asset-studio.html#running);
- Background всех Button и FlatButton сделан через AppCompat стили;
- Все *.png ресурсы только в разрешении xxhdpi, эти ресурсы андроид будет
масштабировать автоматически на более низкие разрешения + переводим в webp;
- Использовать `<shape>` предпочтительнее чем svg и png ресурсы.

MessageController - позволяет показывать SnackBar. Не может использоваться в презентере.
Может использоваться View экрана и дополнительными сущностями скоупа @PerScreen,
например StandardErrorHandler;

Любые локальные действия на экране с AndroidFramework и которые не относятся
к зоне ответственности Вью должны быть обернуты в соответствующие классы с интерфейсом,
независящим от фреймворка и поставляемым в презентер через Dagger.
(например проверка наличия модуля GCM или подписка на BroadcastReceiver)

Вместо нативного ProgressBar используем MaterialProgressBar из этой библиотеки
(для стилизации элемента на prelollipop-устройствах).

NetworkErrorHandler, StandardErrorHandler - обработчик исключений,
возникающих при сетевых запросах;

StandardPlaceHolderView - кастомизируемый плейсхолдер для различных лоад-стейтов.
[custom-view](../custom-view/README.md)

## presenter

Для объединения запросов к репозиториям необходимо использовать
ObservableUtil#combineLatestDelayError() вместо Observable#zip().
Это продиктовано особенностью получения данных.
Каждый Observable может эмитить 2 элемента: один из кеша, другой с сервера.
Observables в этом случае выполняются параллельно.

## ui

Если на экране производится запрос, в течении которого нельзя давать
пользователю взаимодействовать с контентом - используем LoadState.LOADING_TRANSPARENT.
Если при этом запрос не очень важный, лучше блокировать только необходимую часть контента,
при этом демонстрировать PullToRefresh или другой индикатор и скрывать его
при снятии блокировки с UI.


## Interactor

Еще один кейс использования интеракторов: построение событийной модели общения между частями приложения.
Например, некоторое действие на активити А должно вызывать обновление данных на активити Б.
Причем, данное действие не является результатом активити А.
Тогда можно пробросить событие через общий интерактор у данных активити.

## Пагинация

todo

Предусмотрены два модуля datalist-limit-offset и datalist-page-count,
которые предоставляют списки, предназначеные для пагинации.
Также существует BasePaginationableAdapter, расширение которого реализует адаптер для пагинации.



## Best Practice Kotlin

Вью используются через имена в xml в lower_snake_case. Искл: в контроллерах удобнее использовать findViewById или Anko.find(), либо инициализацию через lazy {}

С помощью lazy удобно инициализировать большие объемные списки, объекты.


При использовании nullable-объектов внутри метода, сначала занести ссылку на него в локальную переменную, и проверять на null уже ее.

fun someFun( value: Any?) {
    val temp = value
    if (temp != null) {
        //do something
    }
}

Использовать синтаксис свойств вместо сеттеров.

Обновление кастомных вью делать внутри кастомных сеттеров у изменяемых полей.
var subway: Subway? = null
   set(value) {
       field = value
       updateView()
   }


Для конкатенации элементов списка в строку(например с идентификаторами или именами элементов) удобно использовать метод joinToString().

Для смыслового обозначения Pair(или подобных) удобно использовать typealias, если не требуется дополнительных методов.

Delegates
В Kotlin существует возможность делегировать создание класса другому классу.  Но кроме этого можно делегировать инициализацию свойств в классе некоторому объекту-делегату.
Для этого существует ряд стандартных делегатов:
lazy {}
observable() {}

Lazy предоставляет ленивую инициализацию свойств, т.е. они будут проинициализированы единожды при первом вызове, тем значением , которое возвращает  лямбда.
private val locationManager: LocationManager by lazy {
   (appContext.getSystemService(Context.LOCATION_SERVICE) as LocationManager)
}

Observable - более интересный делегат. Он принимает начальное значение и лямбду , у которой три параметра - присваиваемое свойство(KProperty) , старое и новое значения.
Удобно использовать в случае, когда надо например сравнить старое и новое значение и в зависимости от этого сделать те или иные действия, или же , когда надо сделать “наблюдаемое” свойство(т.е. надо реагировать на его изменения)
private var selectedPinChangeDelegateData: PinSelectedData by Delegates.observable(
PinSelectedData())
{ _, oldValue, newValue ->
   if (newValue != oldValue) {
       pinSelectedSubject.onNext(newValue)
       renderMarkerSelection(oldValue, newValue)
   }
}

Также можно писать свои делегаты. Для этого надо наследоваться от ReadWriteProperty / ReadOnlyProperty и переопределить их методы

Задачка по делегатам на KotlinKoans

Listeners через лямбды.

